% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/PRED_predictNewLocFixedL.R
\name{predictNewLocFixedL}
\alias{predictNewLocFixedL}
\title{predictNewLocFixedL}
\usage{
predictNewLocFixedL(
  object,
  NNewLoc,
  distOrigNew = NULL,
  distNewNew = NULL,
  NewX = NULL,
  NewTrials = NULL,
  Verbose = TRUE,
  seed = 27
)
}
\arguments{
\item{object}{A \code{\link{FixedLbfa}} model object for which predictions
are desired from.}

\item{NNewLoc}{A positive integer indicating the number of new spatial locations for prediction.}

\item{distOrigNew}{An \code{M x NNewLoc} dimensional distance matrix for distances between the original and new spatial points. 
If \code{include.space = FALSE}, then we don't need to specify \code{distOrigNew} and can leave it as its default value \code{NULL}. 
If \code{include.space = TRUE}, then this matrix must be specified no matter the value of the input \code{spatApprox}.
Since \code{spatial.structure} must be \code{"continuous"} to enable predictions at new spatial locations, the matrix should be a continuous distance matrix (e.g., Euclidean).}

\item{distNewNew}{An \code{NNewLoc x NNewLoc} dimensional distance matrix for the new spatial points. 
If \code{include.space = FALSE} or \code{spatApprox = TRUE}, then we don't need to specify \code{distNewNew} and can leave it as its default value \code{NULL}. 
When \code{include.space = TRUE}, the matrix should be a continuous distance matrix (e.g., Euclidean), 
since \code{spatial.structure} must be \code{"continuous"} to enable predictions at new spatial locations.}

\item{NewX}{A matrix including covariates at times \code{1:T} for the new location points. 
\code{NewX} must have dimension \code{(NNewLoc x O x T) x P}, where \code{NNewLoc} is the number of new location
points being predicted. The default sets \code{NewX} to \code{NULL} and assumes that the covariates for all new locations
are the same as the ones corresponding to the last reference location point.}

\item{NewTrials}{An array indicating the trials for categorical predictions. The array must have dimension \code{T x C x NNewLoc}
and contain only non-negative integers. The default sets \code{NewTrials} to \code{NULL} and assumes that the trials for all predictions
are the same as the ones corresponding to the final reference time point.}

\item{Verbose}{A boolean logical indicating whether progress should be output.}

\item{seed}{An integer value used to set the seed for the random number generator.}
}
\value{
\code{predictNewLocFixedL} returns a list containing the following objects.

  \describe{

  \item{\code{Alpha}} {A \code{matrix} of dimension \code{NKeep x (K x (L - 1) x NNewLoc x O)} containing the posterior predicted latent spatial 
  vectors \code{alpha} for the new location(s) we want to predict. NULL when \code{clustering = FALSE} when fitting the main function.
  For each kept row (MCMC iteration) in \code{Alpha}, the corresponding entries are ordered first by observation type, then spatially, 
  then by clustering group, and finally by factor.}
  
  \item{\code{Weights}} {A \code{matrix} of dimension \code{NKeep x (K x L x NNewLoc x O)} containing the posterior predicted \code{weights}
  for the new location(s) we want to predict. This output can be used for clustering the new location point(s). 
  NULL when \code{clustering = FALSE} or \code{storeWeights = FALSE} when fitting the main function.
  For each kept row (MCMC iteration) in \code{Weights}, the corresponding entries are ordered first by observation type, then spatially, 
  then by clustering group, and finally by factor.}
 
  \item{\code{Lambda}}{A \code{matrix} of dimension \code{NKeep x (NNewLoc x O x K)} containing the posterior predicted factor loadings matrices,
  where \code{O} is the number of observation types and \code{K} is the number of latent factors. 
  For each kept MCMC iteration, the corresponding predicted entries for the factor loadings matrix are ordered first by observation type,
  then spatially, and finally by factor. 
  (the first (NNewLoc x O) entries correspond to factor 1, the next (NNewLoc x O) entries correspond to factor 2 and so on;
  the first O rows correspond to the first new location point for prediction, the next O rows correspond to the second new location point for prediction and so on)}

  \item{\code{Y}}{A \code{list} containing \code{NNewLoc} posterior predictive distribution matrices.
  Each matrix is of dimension \code{NKeep x (T x O)}, where \code{T} is the number of time points and \code{O} is the number of observation types.
  For each kept MCMC iteration, the values are ordered first temporally and then by observation type (the first T correspond to the first observation type, 
  the next T correspond to the second observation type and so on). Each matrix is obtained through Bayesian krigging.}
  
  \item{\code{alphaKrigTime}}{Time (in milliseconds) it took to obtain \code{Alpha}. NULL when \code{clustering = FALSE} when fitting the main function.} 
  
  \item{\code{weightsXiLambdaKrigTime}}{Time (in milliseconds) it took to obtain \code{Weights}, \code{Xi}, and \code{Lambda} from \code{Alpha}
             and posterior samples of \code{theta}. NULL when \code{clustering = FALSE} when fitting the main function.}
             
  \item{\code{lambdaKrigTime}}{Time (in milliseconds) it took to obtain \code{Lambda}. NULL when \code{clustering = TRUE} when fitting the main function.}            

  }
}
\description{
Predicts observations at new location point(s) from a \code{\link{FixedLbfa}} or \code{\link{FixedLbfaVAR1}} model.
}
\details{
\code{predictNewLocFixedL} predicts vectors at new spatial location(s).
 The function always returns the predicted factor loadings matrices \code{Lambda} and outcomes (\code{Y}).
 When \code{clustering = TRUE}, the function also returns the posterior predicted latent spatial vectors \code{alpha} for the 
 new spatial location(s), which (when \code{include.space = TRUE}) are obtained via Bayesian kriging when \code{spatApprox = FALSE} 
 and via nearest-neighbor kriging when \code{spatApprox = TRUE}. 
 When \code{clustering = TRUE} and \code{storeWeights = TRUE}, the function also returns the posterior predicted \code{weights}
 for the new location(s) we want to predict.
}
\references{
Yifan Cheng
}
